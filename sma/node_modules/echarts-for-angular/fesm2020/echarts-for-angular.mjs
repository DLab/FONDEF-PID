import * as i0 from '@angular/core';
import { EventEmitter, Directive, Input, Output, NgModule } from '@angular/core';
import * as echarts from 'echarts/core';
import { CanvasRenderer } from 'echarts/renderers';
import { interval } from 'rxjs';
import { filter, map } from 'rxjs/operators';

class HtmlHelper {
    static elementIsFocusable(ele) {
        return ele.getAttribute("tabindex") != null;
    }
    static getWidthSensor(element, periodicityInMiliSeconds = 2000) {
        let oldWidth = element.clientWidth;
        return interval(periodicityInMiliSeconds).pipe(filter(ignore => {
            if (Math.abs(oldWidth - element.clientWidth) > 2) {
                oldWidth = element.clientWidth;
                return true;
            }
            return false;
        }), map(ignore => element.clientWidth));
    }
    static getHeightSensor(element, periodicityInMiliSeconds = 2000) {
        let oldHeight = element.clientHeight;
        return interval(periodicityInMiliSeconds).pipe(filter(ignore => {
            if (Math.abs(oldHeight - element.clientHeight) > 2) {
                oldHeight = element.clientHeight;
                return true;
            }
            return false;
        }), map(ignore => element.clientWidth));
    }
}

class EchartsDirective {
    constructor(_el) {
        this._el = _el;
        this.extentions = [];
        this.isResizable = true;
        this.defaultWidth = 400;
        this.defaultHeight = 400;
        this.periodicityInMiliSeconds = 2000;
        this.theme = '';
        this.chartInit = new EventEmitter();
    }
    ngOnInit() {
        echarts.use([...this.extentions, CanvasRenderer]);
        this._echartsInstance = echarts.init(this._el.nativeElement, this.theme, {
            width: this._el.nativeElement.clientWidth === this.defaultWidth ? 400 : undefined,
            height: this._el.nativeElement.clientHeight === 0 ? this.defaultHeight : undefined
        });
        this.chartInit.emit(this._echartsInstance);
        this._setParams();
        if (this.isResizable) {
            this._addResizbleFunctionality();
        }
    }
    ngOnChanges(changes) {
        if (changes.options && !changes.options.firstChange) {
            this._setParams();
        }
        if (changes.isResizable && !changes.isResizable.firstChange) {
            if (this.isResizable) {
                this._addResizbleFunctionality();
            }
            else {
                if (this._subscription != null)
                    this._subscription.unsubscribe();
            }
        }
    }
    _addResizbleFunctionality() {
        if (this._subscription != null)
            this._subscription.unsubscribe();
        this._subscription = HtmlHelper.getWidthSensor(this._el.nativeElement).subscribe(() => {
            if (this._echartsInstance != null) {
                this._echartsInstance.resize();
            }
        });
    }
    _setParams() {
        if (this._echartsInstance != null && this.options != null) {
            this._echartsInstance.setOption(this.options, true);
        }
    }
    ngOnDestroy() {
        if (this._subscription != null)
            this._subscription.unsubscribe();
    }
}
EchartsDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.8", ngImport: i0, type: EchartsDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
EchartsDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.8", type: EchartsDirective, selector: "[echarts]", inputs: { options: "options", extentions: "extentions", isResizable: "isResizable", defaultWidth: "defaultWidth", defaultHeight: "defaultHeight", periodicityInMiliSeconds: "periodicityInMiliSeconds", theme: "theme" }, outputs: { chartInit: "chartInit" }, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.8", ngImport: i0, type: EchartsDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: "[echarts]"
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { options: [{
                type: Input
            }], extentions: [{
                type: Input
            }], isResizable: [{
                type: Input
            }], defaultWidth: [{
                type: Input
            }], defaultHeight: [{
                type: Input
            }], periodicityInMiliSeconds: [{
                type: Input
            }], theme: [{
                type: Input
            }], chartInit: [{
                type: Output
            }] } });

class EchartsxModule {
}
EchartsxModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.8", ngImport: i0, type: EchartsxModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
EchartsxModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.3.8", ngImport: i0, type: EchartsxModule, declarations: [EchartsDirective], exports: [EchartsDirective] });
EchartsxModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.3.8", ngImport: i0, type: EchartsxModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.8", ngImport: i0, type: EchartsxModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [EchartsDirective],
                    exports: [EchartsDirective]
                }]
        }] });

/*
 * Public API Surface of echartsx
 */

/**
 * Generated bundle index. Do not edit.
 */

export { EchartsDirective, EchartsxModule };
//# sourceMappingURL=echarts-for-angular.mjs.map
