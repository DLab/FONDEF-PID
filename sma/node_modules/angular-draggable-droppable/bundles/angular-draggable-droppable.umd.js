(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs'), require('rxjs/operators'), require('@angular/common'), require('@mattlewis92/dom-autoscroller')) :
    typeof define === 'function' && define.amd ? define('angular-draggable-droppable', ['exports', '@angular/core', 'rxjs', 'rxjs/operators', '@angular/common', '@mattlewis92/dom-autoscroller'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['angular-draggable-droppable'] = {}, global.ng.core, global.rxjs, global.rxjs.operators, global.ng.common, global.autoScroll));
}(this, (function (exports, i0, rxjs, operators, common, autoScroll) { 'use strict';

    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () {
                            return e[k];
                        }
                    });
                }
            });
        }
        n['default'] = e;
        return Object.freeze(n);
    }

    var i0__namespace = /*#__PURE__*/_interopNamespace(i0);
    var autoScroll__default = /*#__PURE__*/_interopDefaultLegacy(autoScroll);

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    /** @deprecated */
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    /** @deprecated */
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
                if (ar || !(i in from)) {
                    if (!ar)
                        ar = Array.prototype.slice.call(from, 0, i);
                    ar[i] = from[i];
                }
            }
        return to.concat(ar || Array.prototype.slice.call(from));
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, state, kind, f) {
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }
    function __classPrivateFieldSet(receiver, state, value, kind, f) {
        if (kind === "m")
            throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    }

    var DraggableHelper = /** @class */ (function () {
        function DraggableHelper() {
            this.currentDrag = new rxjs.Subject();
        }
        return DraggableHelper;
    }());
    DraggableHelper.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function DraggableHelper_Factory() { return new DraggableHelper(); }, token: DraggableHelper, providedIn: "root" });
    DraggableHelper.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];

    /**
     * If the window isn't scrollable, then place this on the scrollable container that draggable elements are inside. e.g.
     * ```html
      <div style="overflow: scroll" mwlDraggableScrollContainer>
        <div mwlDraggable>Drag me!</div>
      </div>
      ```
     */
    var DraggableScrollContainerDirective = /** @class */ (function () {
        /**
         * @hidden
         */
        function DraggableScrollContainerDirective(elementRef) {
            this.elementRef = elementRef;
        }
        return DraggableScrollContainerDirective;
    }());
    DraggableScrollContainerDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[mwlDraggableScrollContainer]',
                },] }
    ];
    DraggableScrollContainerDirective.ctorParameters = function () { return [
        { type: i0.ElementRef }
    ]; };

    function addClass(renderer, element, classToAdd) {
        if (classToAdd) {
            classToAdd
                .split(' ')
                .forEach(function (className) { return renderer.addClass(element.nativeElement, className); });
        }
    }
    function removeClass(renderer, element, classToRemove) {
        if (classToRemove) {
            classToRemove
                .split(' ')
                .forEach(function (className) { return renderer.removeClass(element.nativeElement, className); });
        }
    }

    var DraggableDirective = /** @class */ (function () {
        /**
         * @hidden
         */
        function DraggableDirective(element, renderer, draggableHelper, zone, vcr, scrollContainer, document) {
            this.element = element;
            this.renderer = renderer;
            this.draggableHelper = draggableHelper;
            this.zone = zone;
            this.vcr = vcr;
            this.scrollContainer = scrollContainer;
            this.document = document;
            /**
             * The axis along which the element is draggable
             */
            this.dragAxis = { x: true, y: true };
            /**
             * Snap all drags to an x / y grid
             */
            this.dragSnapGrid = {};
            /**
             * Show a ghost element that shows the drag when dragging
             */
            this.ghostDragEnabled = true;
            /**
             * Show the original element when ghostDragEnabled is true
             */
            this.showOriginalElementWhileDragging = false;
            /**
             * The cursor to use when hovering over a draggable element
             */
            this.dragCursor = '';
            /*
             * Options used to control the behaviour of auto scrolling: https://www.npmjs.com/package/dom-autoscroller
             */
            this.autoScroll = {
                margin: 20,
            };
            /**
             * Called when the element can be dragged along one axis and has the mouse or pointer device pressed on it
             */
            this.dragPointerDown = new i0.EventEmitter();
            /**
             * Called when the element has started to be dragged.
             * Only called after at least one mouse or touch move event.
             * If you call $event.cancelDrag$.emit() it will cancel the current drag
             */
            this.dragStart = new i0.EventEmitter();
            /**
             * Called after the ghost element has been created
             */
            this.ghostElementCreated = new i0.EventEmitter();
            /**
             * Called when the element is being dragged
             */
            this.dragging = new i0.EventEmitter();
            /**
             * Called after the element is dragged
             */
            this.dragEnd = new i0.EventEmitter();
            /**
             * @hidden
             */
            this.pointerDown$ = new rxjs.Subject();
            /**
             * @hidden
             */
            this.pointerMove$ = new rxjs.Subject();
            /**
             * @hidden
             */
            this.pointerUp$ = new rxjs.Subject();
            this.eventListenerSubscriptions = {};
            this.destroy$ = new rxjs.Subject();
            this.timeLongPress = { timerBegin: 0, timerEnd: 0 };
        }
        DraggableDirective.prototype.ngOnInit = function () {
            var _this = this;
            this.checkEventListeners();
            var pointerDragged$ = this.pointerDown$.pipe(operators.filter(function () { return _this.canDrag(); }), operators.mergeMap(function (pointerDownEvent) {
                // fix for https://github.com/mattlewis92/angular-draggable-droppable/issues/61
                // stop mouse events propagating up the chain
                if (pointerDownEvent.event.stopPropagation && !_this.scrollContainer) {
                    pointerDownEvent.event.stopPropagation();
                }
                // hack to prevent text getting selected in safari while dragging
                var globalDragStyle = _this.renderer.createElement('style');
                _this.renderer.setAttribute(globalDragStyle, 'type', 'text/css');
                _this.renderer.appendChild(globalDragStyle, _this.renderer.createText("\n          body * {\n           -moz-user-select: none;\n           -ms-user-select: none;\n           -webkit-user-select: none;\n           user-select: none;\n          }\n        "));
                requestAnimationFrame(function () {
                    _this.document.head.appendChild(globalDragStyle);
                });
                var startScrollPosition = _this.getScrollPosition();
                var scrollContainerScroll$ = new rxjs.Observable(function (observer) {
                    var scrollContainer = _this.scrollContainer
                        ? _this.scrollContainer.elementRef.nativeElement
                        : 'window';
                    return _this.renderer.listen(scrollContainer, 'scroll', function (e) { return observer.next(e); });
                }).pipe(operators.startWith(startScrollPosition), operators.map(function () { return _this.getScrollPosition(); }));
                var currentDrag$ = new rxjs.Subject();
                var cancelDrag$ = new rxjs.ReplaySubject();
                _this.zone.run(function () {
                    _this.dragPointerDown.next({ x: 0, y: 0 });
                });
                var dragComplete$ = rxjs.merge(_this.pointerUp$, _this.pointerDown$, cancelDrag$, _this.destroy$).pipe(operators.share());
                var pointerMove = rxjs.combineLatest([
                    _this.pointerMove$,
                    scrollContainerScroll$,
                ]).pipe(operators.map(function (_a) {
                    var _b = __read(_a, 2), pointerMoveEvent = _b[0], scroll = _b[1];
                    return {
                        currentDrag$: currentDrag$,
                        transformX: pointerMoveEvent.clientX - pointerDownEvent.clientX,
                        transformY: pointerMoveEvent.clientY - pointerDownEvent.clientY,
                        clientX: pointerMoveEvent.clientX,
                        clientY: pointerMoveEvent.clientY,
                        scrollLeft: scroll.left,
                        scrollTop: scroll.top,
                        target: pointerMoveEvent.event.target,
                    };
                }), operators.map(function (moveData) {
                    if (_this.dragSnapGrid.x) {
                        moveData.transformX =
                            Math.round(moveData.transformX / _this.dragSnapGrid.x) *
                                _this.dragSnapGrid.x;
                    }
                    if (_this.dragSnapGrid.y) {
                        moveData.transformY =
                            Math.round(moveData.transformY / _this.dragSnapGrid.y) *
                                _this.dragSnapGrid.y;
                    }
                    return moveData;
                }), operators.map(function (moveData) {
                    if (!_this.dragAxis.x) {
                        moveData.transformX = 0;
                    }
                    if (!_this.dragAxis.y) {
                        moveData.transformY = 0;
                    }
                    return moveData;
                }), operators.map(function (moveData) {
                    var scrollX = moveData.scrollLeft - startScrollPosition.left;
                    var scrollY = moveData.scrollTop - startScrollPosition.top;
                    return Object.assign(Object.assign({}, moveData), { x: moveData.transformX + scrollX, y: moveData.transformY + scrollY });
                }), operators.filter(function (_a) {
                    var x = _a.x, y = _a.y, transformX = _a.transformX, transformY = _a.transformY;
                    return !_this.validateDrag ||
                        _this.validateDrag({
                            x: x,
                            y: y,
                            transform: { x: transformX, y: transformY },
                        });
                }), operators.takeUntil(dragComplete$), operators.share());
                var dragStarted$ = pointerMove.pipe(operators.take(1), operators.share());
                var dragEnded$ = pointerMove.pipe(operators.takeLast(1), operators.share());
                dragStarted$.subscribe(function (_a) {
                    var clientX = _a.clientX, clientY = _a.clientY, x = _a.x, y = _a.y;
                    _this.zone.run(function () {
                        _this.dragStart.next({ cancelDrag$: cancelDrag$ });
                    });
                    _this.scroller = autoScroll__default['default']([
                        _this.scrollContainer
                            ? _this.scrollContainer.elementRef.nativeElement
                            : _this.document.defaultView,
                    ], Object.assign(Object.assign({}, _this.autoScroll), { autoScroll: function () {
                            return true;
                        } }));
                    addClass(_this.renderer, _this.element, _this.dragActiveClass);
                    if (_this.ghostDragEnabled) {
                        var rect = _this.element.nativeElement.getBoundingClientRect();
                        var clone_1 = _this.element.nativeElement.cloneNode(true);
                        if (!_this.showOriginalElementWhileDragging) {
                            _this.renderer.setStyle(_this.element.nativeElement, 'visibility', 'hidden');
                        }
                        if (_this.ghostElementAppendTo) {
                            _this.ghostElementAppendTo.appendChild(clone_1);
                        }
                        else {
                            _this.element.nativeElement.parentNode.insertBefore(clone_1, _this.element.nativeElement.nextSibling);
                        }
                        _this.ghostElement = clone_1;
                        _this.document.body.style.cursor = _this.dragCursor;
                        _this.setElementStyles(clone_1, {
                            position: 'fixed',
                            top: rect.top + "px",
                            left: rect.left + "px",
                            width: rect.width + "px",
                            height: rect.height + "px",
                            cursor: _this.dragCursor,
                            margin: '0',
                            willChange: 'transform',
                            pointerEvents: 'none',
                        });
                        if (_this.ghostElementTemplate) {
                            var viewRef_1 = _this.vcr.createEmbeddedView(_this.ghostElementTemplate);
                            clone_1.innerHTML = '';
                            viewRef_1.rootNodes
                                .filter(function (node) { return node instanceof Node; })
                                .forEach(function (node) {
                                clone_1.appendChild(node);
                            });
                            dragEnded$.subscribe(function () {
                                _this.vcr.remove(_this.vcr.indexOf(viewRef_1));
                            });
                        }
                        _this.zone.run(function () {
                            _this.ghostElementCreated.emit({
                                clientX: clientX - x,
                                clientY: clientY - y,
                                element: clone_1,
                            });
                        });
                        dragEnded$.subscribe(function () {
                            clone_1.parentElement.removeChild(clone_1);
                            _this.ghostElement = null;
                            _this.renderer.setStyle(_this.element.nativeElement, 'visibility', '');
                        });
                    }
                    _this.draggableHelper.currentDrag.next(currentDrag$);
                });
                dragEnded$
                    .pipe(operators.mergeMap(function (dragEndData) {
                    var dragEndData$ = cancelDrag$.pipe(operators.count(), operators.take(1), operators.map(function (calledCount) { return (Object.assign(Object.assign({}, dragEndData), { dragCancelled: calledCount > 0 })); }));
                    cancelDrag$.complete();
                    return dragEndData$;
                }))
                    .subscribe(function (_a) {
                    var x = _a.x, y = _a.y, dragCancelled = _a.dragCancelled;
                    _this.scroller.destroy();
                    _this.zone.run(function () {
                        _this.dragEnd.next({ x: x, y: y, dragCancelled: dragCancelled });
                    });
                    removeClass(_this.renderer, _this.element, _this.dragActiveClass);
                    currentDrag$.complete();
                });
                rxjs.merge(dragComplete$, dragEnded$)
                    .pipe(operators.take(1))
                    .subscribe(function () {
                    requestAnimationFrame(function () {
                        _this.document.head.removeChild(globalDragStyle);
                    });
                });
                return pointerMove;
            }), operators.share());
            rxjs.merge(pointerDragged$.pipe(operators.take(1), operators.map(function (value) { return [, value]; })), pointerDragged$.pipe(operators.pairwise()))
                .pipe(operators.filter(function (_a) {
                var _b = __read(_a, 2), previous = _b[0], next = _b[1];
                if (!previous) {
                    return true;
                }
                return previous.x !== next.x || previous.y !== next.y;
            }), operators.map(function (_a) {
                var _b = __read(_a, 2), previous = _b[0], next = _b[1];
                return next;
            }))
                .subscribe(function (_a) {
                var x = _a.x, y = _a.y, currentDrag$ = _a.currentDrag$, clientX = _a.clientX, clientY = _a.clientY, transformX = _a.transformX, transformY = _a.transformY, target = _a.target;
                _this.zone.run(function () {
                    _this.dragging.next({ x: x, y: y });
                });
                requestAnimationFrame(function () {
                    if (_this.ghostElement) {
                        var transform = "translate3d(" + transformX + "px, " + transformY + "px, 0px)";
                        _this.setElementStyles(_this.ghostElement, {
                            transform: transform,
                            '-webkit-transform': transform,
                            '-ms-transform': transform,
                            '-moz-transform': transform,
                            '-o-transform': transform,
                        });
                    }
                });
                currentDrag$.next({
                    clientX: clientX,
                    clientY: clientY,
                    dropData: _this.dropData,
                    target: target,
                });
            });
        };
        DraggableDirective.prototype.ngOnChanges = function (changes) {
            if (changes.dragAxis) {
                this.checkEventListeners();
            }
        };
        DraggableDirective.prototype.ngOnDestroy = function () {
            this.unsubscribeEventListeners();
            this.pointerDown$.complete();
            this.pointerMove$.complete();
            this.pointerUp$.complete();
            this.destroy$.next();
        };
        DraggableDirective.prototype.checkEventListeners = function () {
            var _this = this;
            var canDrag = this.canDrag();
            var hasEventListeners = Object.keys(this.eventListenerSubscriptions).length > 0;
            if (canDrag && !hasEventListeners) {
                this.zone.runOutsideAngular(function () {
                    _this.eventListenerSubscriptions.mousedown = _this.renderer.listen(_this.element.nativeElement, 'mousedown', function (event) {
                        _this.onMouseDown(event);
                    });
                    _this.eventListenerSubscriptions.mouseup = _this.renderer.listen('document', 'mouseup', function (event) {
                        _this.onMouseUp(event);
                    });
                    _this.eventListenerSubscriptions.touchstart = _this.renderer.listen(_this.element.nativeElement, 'touchstart', function (event) {
                        _this.onTouchStart(event);
                    });
                    _this.eventListenerSubscriptions.touchend = _this.renderer.listen('document', 'touchend', function (event) {
                        _this.onTouchEnd(event);
                    });
                    _this.eventListenerSubscriptions.touchcancel = _this.renderer.listen('document', 'touchcancel', function (event) {
                        _this.onTouchEnd(event);
                    });
                    _this.eventListenerSubscriptions.mouseenter = _this.renderer.listen(_this.element.nativeElement, 'mouseenter', function () {
                        _this.onMouseEnter();
                    });
                    _this.eventListenerSubscriptions.mouseleave = _this.renderer.listen(_this.element.nativeElement, 'mouseleave', function () {
                        _this.onMouseLeave();
                    });
                });
            }
            else if (!canDrag && hasEventListeners) {
                this.unsubscribeEventListeners();
            }
        };
        DraggableDirective.prototype.onMouseDown = function (event) {
            var _this = this;
            if (event.button === 0) {
                if (!this.eventListenerSubscriptions.mousemove) {
                    this.eventListenerSubscriptions.mousemove = this.renderer.listen('document', 'mousemove', function (mouseMoveEvent) {
                        _this.pointerMove$.next({
                            event: mouseMoveEvent,
                            clientX: mouseMoveEvent.clientX,
                            clientY: mouseMoveEvent.clientY,
                        });
                    });
                }
                this.pointerDown$.next({
                    event: event,
                    clientX: event.clientX,
                    clientY: event.clientY,
                });
            }
        };
        DraggableDirective.prototype.onMouseUp = function (event) {
            if (event.button === 0) {
                if (this.eventListenerSubscriptions.mousemove) {
                    this.eventListenerSubscriptions.mousemove();
                    delete this.eventListenerSubscriptions.mousemove;
                }
                this.pointerUp$.next({
                    event: event,
                    clientX: event.clientX,
                    clientY: event.clientY,
                });
            }
        };
        DraggableDirective.prototype.onTouchStart = function (event) {
            var _this = this;
            var startScrollPosition;
            var isDragActivated;
            var hasContainerScrollbar;
            if (this.touchStartLongPress) {
                this.timeLongPress.timerBegin = Date.now();
                isDragActivated = false;
                hasContainerScrollbar = this.hasScrollbar();
                startScrollPosition = this.getScrollPosition();
            }
            if (!this.eventListenerSubscriptions.touchmove) {
                var contextMenuListener_1 = rxjs.fromEvent(this.document, 'contextmenu').subscribe(function (e) {
                    e.preventDefault();
                });
                var touchMoveListener_1 = rxjs.fromEvent(this.document, 'touchmove', {
                    passive: false,
                }).subscribe(function (touchMoveEvent) {
                    if (_this.touchStartLongPress &&
                        !isDragActivated &&
                        hasContainerScrollbar) {
                        isDragActivated = _this.shouldBeginDrag(event, touchMoveEvent, startScrollPosition);
                    }
                    if (!_this.touchStartLongPress ||
                        !hasContainerScrollbar ||
                        isDragActivated) {
                        touchMoveEvent.preventDefault();
                        _this.pointerMove$.next({
                            event: touchMoveEvent,
                            clientX: touchMoveEvent.targetTouches[0].clientX,
                            clientY: touchMoveEvent.targetTouches[0].clientY,
                        });
                    }
                });
                this.eventListenerSubscriptions.touchmove = function () {
                    contextMenuListener_1.unsubscribe();
                    touchMoveListener_1.unsubscribe();
                };
            }
            this.pointerDown$.next({
                event: event,
                clientX: event.touches[0].clientX,
                clientY: event.touches[0].clientY,
            });
        };
        DraggableDirective.prototype.onTouchEnd = function (event) {
            if (this.eventListenerSubscriptions.touchmove) {
                this.eventListenerSubscriptions.touchmove();
                delete this.eventListenerSubscriptions.touchmove;
                if (this.touchStartLongPress) {
                    this.enableScroll();
                }
            }
            this.pointerUp$.next({
                event: event,
                clientX: event.changedTouches[0].clientX,
                clientY: event.changedTouches[0].clientY,
            });
        };
        DraggableDirective.prototype.onMouseEnter = function () {
            this.setCursor(this.dragCursor);
        };
        DraggableDirective.prototype.onMouseLeave = function () {
            this.setCursor('');
        };
        DraggableDirective.prototype.canDrag = function () {
            return this.dragAxis.x || this.dragAxis.y;
        };
        DraggableDirective.prototype.setCursor = function (value) {
            if (!this.eventListenerSubscriptions.mousemove) {
                this.renderer.setStyle(this.element.nativeElement, 'cursor', value);
            }
        };
        DraggableDirective.prototype.unsubscribeEventListeners = function () {
            var _this = this;
            Object.keys(this.eventListenerSubscriptions).forEach(function (type) {
                _this.eventListenerSubscriptions[type]();
                delete _this.eventListenerSubscriptions[type];
            });
        };
        DraggableDirective.prototype.setElementStyles = function (element, styles) {
            var _this = this;
            Object.keys(styles).forEach(function (key) {
                _this.renderer.setStyle(element, key, styles[key]);
            });
        };
        DraggableDirective.prototype.getScrollElement = function () {
            if (this.scrollContainer) {
                return this.scrollContainer.elementRef.nativeElement;
            }
            else {
                return this.document.body;
            }
        };
        DraggableDirective.prototype.getScrollPosition = function () {
            if (this.scrollContainer) {
                return {
                    top: this.scrollContainer.elementRef.nativeElement.scrollTop,
                    left: this.scrollContainer.elementRef.nativeElement.scrollLeft,
                };
            }
            else {
                return {
                    top: window.pageYOffset || this.document.documentElement.scrollTop,
                    left: window.pageXOffset || this.document.documentElement.scrollLeft,
                };
            }
        };
        DraggableDirective.prototype.shouldBeginDrag = function (event, touchMoveEvent, startScrollPosition) {
            var moveScrollPosition = this.getScrollPosition();
            var deltaScroll = {
                top: Math.abs(moveScrollPosition.top - startScrollPosition.top),
                left: Math.abs(moveScrollPosition.left - startScrollPosition.left),
            };
            var deltaX = Math.abs(touchMoveEvent.targetTouches[0].clientX - event.touches[0].clientX) - deltaScroll.left;
            var deltaY = Math.abs(touchMoveEvent.targetTouches[0].clientY - event.touches[0].clientY) - deltaScroll.top;
            var deltaTotal = deltaX + deltaY;
            var longPressConfig = this.touchStartLongPress;
            if (deltaTotal > longPressConfig.delta ||
                deltaScroll.top > 0 ||
                deltaScroll.left > 0) {
                this.timeLongPress.timerBegin = Date.now();
            }
            this.timeLongPress.timerEnd = Date.now();
            var duration = this.timeLongPress.timerEnd - this.timeLongPress.timerBegin;
            if (duration >= longPressConfig.delay) {
                this.disableScroll();
                return true;
            }
            return false;
        };
        DraggableDirective.prototype.enableScroll = function () {
            if (this.scrollContainer) {
                this.renderer.setStyle(this.scrollContainer.elementRef.nativeElement, 'overflow', '');
            }
            this.renderer.setStyle(this.document.body, 'overflow', '');
        };
        DraggableDirective.prototype.disableScroll = function () {
            /* istanbul ignore next */
            if (this.scrollContainer) {
                this.renderer.setStyle(this.scrollContainer.elementRef.nativeElement, 'overflow', 'hidden');
            }
            this.renderer.setStyle(this.document.body, 'overflow', 'hidden');
        };
        DraggableDirective.prototype.hasScrollbar = function () {
            var scrollContainer = this.getScrollElement();
            var containerHasHorizontalScroll = scrollContainer.scrollWidth > scrollContainer.clientWidth;
            var containerHasVerticalScroll = scrollContainer.scrollHeight > scrollContainer.clientHeight;
            return containerHasHorizontalScroll || containerHasVerticalScroll;
        };
        return DraggableDirective;
    }());
    DraggableDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[mwlDraggable]',
                },] }
    ];
    DraggableDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.Renderer2 },
        { type: DraggableHelper },
        { type: i0.NgZone },
        { type: i0.ViewContainerRef },
        { type: DraggableScrollContainerDirective, decorators: [{ type: i0.Optional }] },
        { type: undefined, decorators: [{ type: i0.Inject, args: [common.DOCUMENT,] }] }
    ]; };
    DraggableDirective.propDecorators = {
        dropData: [{ type: i0.Input }],
        dragAxis: [{ type: i0.Input }],
        dragSnapGrid: [{ type: i0.Input }],
        ghostDragEnabled: [{ type: i0.Input }],
        showOriginalElementWhileDragging: [{ type: i0.Input }],
        validateDrag: [{ type: i0.Input }],
        dragCursor: [{ type: i0.Input }],
        dragActiveClass: [{ type: i0.Input }],
        ghostElementAppendTo: [{ type: i0.Input }],
        ghostElementTemplate: [{ type: i0.Input }],
        touchStartLongPress: [{ type: i0.Input }],
        autoScroll: [{ type: i0.Input }],
        dragPointerDown: [{ type: i0.Output }],
        dragStart: [{ type: i0.Output }],
        ghostElementCreated: [{ type: i0.Output }],
        dragging: [{ type: i0.Output }],
        dragEnd: [{ type: i0.Output }]
    };

    function isCoordinateWithinRectangle(clientX, clientY, rect) {
        return (clientX >= rect.left &&
            clientX <= rect.right &&
            clientY >= rect.top &&
            clientY <= rect.bottom);
    }
    var DroppableDirective = /** @class */ (function () {
        function DroppableDirective(element, draggableHelper, zone, renderer, scrollContainer) {
            this.element = element;
            this.draggableHelper = draggableHelper;
            this.zone = zone;
            this.renderer = renderer;
            this.scrollContainer = scrollContainer;
            /**
             * Called when a draggable element starts overlapping the element
             */
            this.dragEnter = new i0.EventEmitter();
            /**
             * Called when a draggable element stops overlapping the element
             */
            this.dragLeave = new i0.EventEmitter();
            /**
             * Called when a draggable element is moved over the element
             */
            this.dragOver = new i0.EventEmitter();
            /**
             * Called when a draggable element is dropped on this element
             */
            this.drop = new i0.EventEmitter(); // eslint-disable-line  @angular-eslint/no-output-native
        }
        DroppableDirective.prototype.ngOnInit = function () {
            var _this = this;
            this.currentDragSubscription = this.draggableHelper.currentDrag.subscribe(function (drag$) {
                addClass(_this.renderer, _this.element, _this.dragActiveClass);
                var droppableElement = {
                    updateCache: true,
                };
                var deregisterScrollListener = _this.renderer.listen(_this.scrollContainer
                    ? _this.scrollContainer.elementRef.nativeElement
                    : 'window', 'scroll', function () {
                    droppableElement.updateCache = true;
                });
                var currentDragDropData;
                var overlaps$ = drag$.pipe(operators.map(function (_a) {
                    var clientX = _a.clientX, clientY = _a.clientY, dropData = _a.dropData, target = _a.target;
                    currentDragDropData = dropData;
                    if (droppableElement.updateCache) {
                        droppableElement.rect =
                            _this.element.nativeElement.getBoundingClientRect();
                        if (_this.scrollContainer) {
                            droppableElement.scrollContainerRect =
                                _this.scrollContainer.elementRef.nativeElement.getBoundingClientRect();
                        }
                        droppableElement.updateCache = false;
                    }
                    var isWithinElement = isCoordinateWithinRectangle(clientX, clientY, droppableElement.rect);
                    var isDropAllowed = !_this.validateDrop ||
                        _this.validateDrop({ clientX: clientX, clientY: clientY, target: target });
                    if (droppableElement.scrollContainerRect) {
                        return (isWithinElement &&
                            isDropAllowed &&
                            isCoordinateWithinRectangle(clientX, clientY, droppableElement.scrollContainerRect));
                    }
                    else {
                        return isWithinElement && isDropAllowed;
                    }
                }));
                var overlapsChanged$ = overlaps$.pipe(operators.distinctUntilChanged());
                var dragOverActive; // TODO - see if there's a way of doing this via rxjs
                overlapsChanged$
                    .pipe(operators.filter(function (overlapsNow) { return overlapsNow; }))
                    .subscribe(function () {
                    dragOverActive = true;
                    addClass(_this.renderer, _this.element, _this.dragOverClass);
                    _this.zone.run(function () {
                        _this.dragEnter.next({
                            dropData: currentDragDropData,
                        });
                    });
                });
                overlaps$.pipe(operators.filter(function (overlapsNow) { return overlapsNow; })).subscribe(function () {
                    _this.zone.run(function () {
                        _this.dragOver.next({
                            dropData: currentDragDropData,
                        });
                    });
                });
                overlapsChanged$
                    .pipe(operators.pairwise(), operators.filter(function (_a) {
                    var _b = __read(_a, 2), didOverlap = _b[0], overlapsNow = _b[1];
                    return didOverlap && !overlapsNow;
                }))
                    .subscribe(function () {
                    dragOverActive = false;
                    removeClass(_this.renderer, _this.element, _this.dragOverClass);
                    _this.zone.run(function () {
                        _this.dragLeave.next({
                            dropData: currentDragDropData,
                        });
                    });
                });
                drag$.subscribe({
                    complete: function () {
                        deregisterScrollListener();
                        removeClass(_this.renderer, _this.element, _this.dragActiveClass);
                        if (dragOverActive) {
                            removeClass(_this.renderer, _this.element, _this.dragOverClass);
                            _this.zone.run(function () {
                                _this.drop.next({
                                    dropData: currentDragDropData,
                                });
                            });
                        }
                    },
                });
            });
        };
        DroppableDirective.prototype.ngOnDestroy = function () {
            if (this.currentDragSubscription) {
                this.currentDragSubscription.unsubscribe();
            }
        };
        return DroppableDirective;
    }());
    DroppableDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[mwlDroppable]',
                },] }
    ];
    DroppableDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: DraggableHelper },
        { type: i0.NgZone },
        { type: i0.Renderer2 },
        { type: DraggableScrollContainerDirective, decorators: [{ type: i0.Optional }] }
    ]; };
    DroppableDirective.propDecorators = {
        dragOverClass: [{ type: i0.Input }],
        dragActiveClass: [{ type: i0.Input }],
        validateDrop: [{ type: i0.Input }],
        dragEnter: [{ type: i0.Output }],
        dragLeave: [{ type: i0.Output }],
        dragOver: [{ type: i0.Output }],
        drop: [{ type: i0.Output }]
    };

    var DragAndDropModule = /** @class */ (function () {
        function DragAndDropModule() {
        }
        return DragAndDropModule;
    }());
    DragAndDropModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [
                        DraggableDirective,
                        DroppableDirective,
                        DraggableScrollContainerDirective,
                    ],
                    exports: [
                        DraggableDirective,
                        DroppableDirective,
                        DraggableScrollContainerDirective,
                    ],
                },] }
    ];

    /*
     * Public API Surface of angular-draggable-droppable
     */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.DragAndDropModule = DragAndDropModule;
    exports.DraggableDirective = DraggableDirective;
    exports.DraggableScrollContainerDirective = DraggableScrollContainerDirective;
    exports.DroppableDirective = DroppableDirective;
    exports.ɵa = DraggableHelper;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=angular-draggable-droppable.umd.js.map
